<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 命叔瞎扯</title><link>https://oldrev.github.io/posts/</link><description>Recent content in Posts on 命叔瞎扯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>李维（Li Wei）</copyright><lastBuildDate>Thu, 19 Sep 2024 12:00:00 +0800</lastBuildDate><atom:link href="https://oldrev.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 交叉编译后用 QEMU 执行单元测试</title><link>https://oldrev.github.io/2024/09/rust-cross-qemu-test/</link><pubDate>Thu, 19 Sep 2024 12:00:00 +0800</pubDate><guid>https://oldrev.github.io/2024/09/rust-cross-qemu-test/</guid><description>TL;DR 本文介绍一种在 Linux 下通过 qemu-user-static 工具对交叉编译的 Rust 程序执行单元测试的方法。
为何有此需求？ 最近用 Rust 做嵌入式 Linux 开发的时候，交叉编译完程序以后，为了保证质量，还需要对目标平台执行单元测试。问题来了，“qemu-user-static”只能转译执行单个可执行文件，而一般 Rust 程序的单元测试是通过 cargo test 来执行的。解决这个问题的思路我们需要把单元测试编译成一个或者多个可执行文件让 QEMU 来执行，通过观察普通 cargo test 的执行过程，我发现它本身就是把单元测试编译成一个可执行程序来执行的，只是该可执行文件的名称会在后面加上源码的哈希值，所以在持续集成等环境下，我们需要确定输出的可执行文件名。
调研 Cargo Test 到了这一步，问题转换成了获取 Cargo 构建后测试可执行文件名，我看了下 cargo test --help 发现并没有此项参数，但是另外两个参数引起了我的注意：
--no-run：此参数仅编译生成可执行的测试程序，而不实际执行单元测试。这对于交叉编译后的结果尤为重要，因为 Cargo 无法直接在本地执行目标平台的测试。
--message-format=json 表示使用 JSON 格式来输出构建信息到标准输出，带上这个参数执行 cargo test --message-format=json，可以观察到最后输出了类似如下的 JSON 内容：
{ &amp;#34;reason&amp;#34;: &amp;#34;compiler-artifact&amp;#34;, &amp;#34;target&amp;#34;: { /* ... */ }, &amp;#34;profile&amp;#34;: { &amp;#34;test&amp;#34;: true // 这里为 true 表示编译的 profile 就是测试 /*... */ }, &amp;#34;features&amp;#34;: [ /*.</description></item><item><title>使用 GCC 语句表达式模仿异常，简化错误处理</title><link>https://oldrev.github.io/2024/09/gcc-stateexpr/</link><pubDate>Sat, 14 Sep 2024 04:42:39 +0800</pubDate><guid>https://oldrev.github.io/2024/09/gcc-stateexpr/</guid><description>嵌入式开发里，90% 情况下用的是 GCC，这里介绍一个 GCC 的 C 语言语法扩展，叫“语句表达式”（Statement Expression）。语句表达式，允许在表达式中包含多个语句，并返回最后一个表达式语句的值，比如：
#include &amp;lt;stdio.h&amp;gt; int main() { int a = 5, b = 10; int result = ({ printf(&amp;#34;Calculating the sum of %d and %d\n&amp;#34;, a, b); a + b; }); printf(&amp;#34;The result is %d\n&amp;#34;, result); return 0; } 在这个例子中，({ ... }) 是一个语句表达式。它首先会打印一条调试信息，然后计算 a + b 并将结果返回给 result。
有了这个工具，可以很容易实现一个 TRY 宏：
#define TRY(expr, msg) ({ \ int result = (expr); \ if (result != 0) { \ fprintf(stderr, &amp;#34;Error: %s\n&amp;#34;, msg); \ return result; \ } \ }) 这个宏里，我们判断 expr 是否等于 0，如果成功则继续执行，否则打印 msg 并提前返回，以下是完整可以跑的示例代码：</description></item><item><title>Hello World</title><link>https://oldrev.github.io/2024/09/hello-world/</link><pubDate>Sat, 14 Sep 2024 00:44:25 +0800</pubDate><guid>https://oldrev.github.io/2024/09/hello-world/</guid><description>整个测试下</description></item></channel></rss>