<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>命叔瞎扯</title><link>https://oldrev.github.io/en/</link><description>Recent content on 命叔瞎扯</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>李维（Li Wei）</copyright><lastBuildDate>Thu, 19 Sep 2024 12:00:00 +0800</lastBuildDate><atom:link href="https://oldrev.github.io/en/index.xml" rel="self" type="application/rss+xml"/><item><title>Compile Rust with cross-compilation and run the unit tests using QEMU</title><link>https://oldrev.github.io/en/post/2024/09/rust-cross-qemu-test/</link><pubDate>Thu, 19 Sep 2024 12:00:00 +0800</pubDate><guid>https://oldrev.github.io/en/post/2024/09/rust-cross-qemu-test/</guid><description>命叔瞎扯 https://oldrev.github.io/en/post/2024/09/rust-cross-qemu-test/ -&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>This post introduces a method to run unit tests for cross-compiled Rust programs on Linux using the &lt;code>qemu-user-static&lt;/code> tool.&lt;/p>
&lt;h2 id="why-this-need">Why This Need?&lt;/h2>
&lt;p>Recently, while working on embedded Linux development with Rust, I needed to run unit tests on the target platform after cross-compiling the program to ensure quality. The challenge was that &amp;ldquo;qemu-user-static&amp;rdquo; can only translate and execute individual executable files, while Rust&amp;rsquo;s unit tests are typically run using &lt;code>cargo test&lt;/code>. To solve this, we need to compile the unit tests into one or more executable files for QEMU to run. By observing the execution process of &lt;code>cargo test&lt;/code>, I found that it actually compiles the unit tests into an executable program, but the name of this executable is appended with a hash of the source code. Therefore, in continuous integration environments, we need to determine the output executable file name.&lt;/p>
&lt;h2 id="investigating-cargo-test">Investigating Cargo Test&lt;/h2>
&lt;p>At this point, the problem shifts to obtaining the test executable file name after Cargo builds. I checked &lt;code>cargo test --help&lt;/code> and found no such parameter, but two other parameters caught my attention:&lt;/p>
&lt;p>&lt;code>--no-run&lt;/code>: This parameter compiles the test program without actually running the unit tests. This is crucial for cross-compilation results since Cargo cannot directly execute target platform tests locally.&lt;/p>
&lt;p>&lt;code>--message-format=json&lt;/code>: This outputs build information in JSON format to standard output. Running &lt;code>cargo test --message-format=json&lt;/code> with this parameter, you can observe JSON output like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;reason&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;compiler-artifact&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;target&amp;#34;&lt;/span>: { &lt;span style="color:#960050;background-color:#1e0010">/*&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">*/&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;profile&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;test&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e">// true here indicates this is a test build
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">/*...&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;features&amp;#34;&lt;/span>: [ &lt;span style="color:#960050;background-color:#1e0010">/*...*/&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;filenames&amp;#34;&lt;/span>: [ &lt;span style="color:#960050;background-color:#1e0010">/*...*/&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// This is the output test executable file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">&amp;#34;executable&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;/YOUR_PROJ/target/YOUR_TARGET/debug/deps/your_executable-9a3afc990e4f7858&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">/*&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">...&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This JSON contains all the information we need: whether the output is a test build result and the path to the test program.&lt;/p>
&lt;h2 id="solution">Solution&lt;/h2>
&lt;p>With the problem clearly defined, the solution becomes straightforward. We can use command-line tools like &lt;code>jq&lt;/code> to extract the executable file path from the JSON output of &lt;code>cargo test&lt;/code> and pass it to QEMU for execution. Of course, you can also write a Python script for greater flexibility.&lt;/p>
&lt;h2 id="an-example">An Example&lt;/h2>
&lt;p>Assuming you&amp;rsquo;re on Ubuntu, first install the necessary tools:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install qemu qemu-user-static jq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Navigate to your Rust project and write a simple Bash script to cross-compile and run tests. Here, we assume the target platform is 32-bit ARM with hardware floating point:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> exe in &lt;span style="color:#66d9ef">$(&lt;/span>cargo test --no-run --target armv7-unknown-linux-gnueabihf --message-format&lt;span style="color:#f92672">=&lt;/span>json | tee /dev/stderr | jq -r &lt;span style="color:#e6db74">&amp;#39;select(.profile.test == true) | .executable&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;Running tests in &lt;/span>$exe&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> qemu-arm -L /usr/arm-linux-gnueabihf $exe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This script is simple: it pipes the output of &lt;code>cargo test&lt;/code> to &lt;code>tee&lt;/code>, which is optional but useful for debugging by displaying the JSON on the command line. The JSON is then piped to &lt;code>jq&lt;/code> to extract the executable file path into &lt;code>$exe&lt;/code> and pass it to QEMU for execution. The loop is necessary because if your project contains multiple crates, Cargo will generate a test program for each crate.&lt;/p>
&lt;p>For other architectures like ARM64, simply change the &lt;code>--target&lt;/code> parameter in Cargo to the corresponding Rust build target and adjust the &lt;code>qemu-arm&lt;/code> command and &lt;code>/usr/arm-linux-gnueabihf&lt;/code> path accordingly. A complete example can be found in my open-source project EdgeLink&amp;rsquo;s continuous integration file: &lt;a href="https://github.com/oldrev/edgelink/blob/master/.github/workflows/CICD.yml">https://github.com/oldrev/edgelink/blob/master/.github/workflows/CICD.yml&lt;/a>&lt;/p>
- https://oldrev.github.io/en/post/2024/09/rust-cross-qemu-test/ - 李维（Li Wei）</description></item></channel></rss>