<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>命叔瞎扯</title><link>https://oldrev.github.io/</link><description>Recent content on 命叔瞎扯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>李维（Li Wei）</copyright><lastBuildDate>Sat, 14 Sep 2024 04:42:39 +0800</lastBuildDate><atom:link href="https://oldrev.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 GCC 语句表达式模仿异常，简化错误处理</title><link>https://oldrev.github.io/2024/09/gcc-stateexpr/</link><pubDate>Sat, 14 Sep 2024 04:42:39 +0800</pubDate><guid>https://oldrev.github.io/2024/09/gcc-stateexpr/</guid><description>命叔瞎扯 https://oldrev.github.io/2024/09/gcc-stateexpr/ -&lt;p>嵌入式开发里，90% 情况下用的是 GCC，这里介绍一个 GCC 的 C 语言语法扩展，叫“语句表达式”（Statement Expression）。语句表达式，允许在表达式中包含多个语句，并返回最后一个表达式语句的值，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>, b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> ({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Calculating the sum of %d and %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, a, b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;The result is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，&lt;code>({ ... })&lt;/code> 是一个语句表达式。它首先会打印一条调试信息，然后计算 &lt;code>a + b&lt;/code> 并将结果返回给 &lt;code>result&lt;/code>。&lt;/p>
&lt;p>有了这个工具，可以很容易实现一个 &lt;code>TRY&lt;/code> 宏：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define TRY(expr, msg) ({ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> int result = (expr); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> if (result != 0) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> fprintf(stderr, &amp;#34;Error: %s\n&amp;#34;, msg); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> return result; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">})
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个宏里，我们判断 &lt;code>expr&lt;/code> 是否等于 &lt;code>0&lt;/code>，如果成功则继续执行，否则打印 &lt;code>msg&lt;/code> 并提前返回，以下是完整可以跑的示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define TRY(expr, msg) ({ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> int result = (expr); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> if (result != 0) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> fprintf(stderr, &amp;#34;Error: %s\n&amp;#34;, msg); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> return result; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">})
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">some_function&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 假设这是一个可能失败的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 成功返回 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// return -1; // 失败返回非零值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">TRY&lt;/span>(&lt;span style="color:#a6e22e">some_function&lt;/span>(), &lt;span style="color:#e6db74">&amp;#34;some_function failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Function succeeded, continuing...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用这个宏的时候有个要求，&lt;code>expr&lt;/code> 里的函数或者表达式必须以 &lt;code>int&lt;/code> 作为返回值。如果你不需要打印错误信息，可以直接去掉 &lt;code>msg&lt;/code> 参数，返回错误码就好。&lt;/p>
&lt;p>基本上 Rust 的 &lt;code>Ok/Err&lt;/code> 也是一样的原理，这个宏你还可以扩展，比如现在我们的宏里可以使用任何结果为 &lt;code>int&lt;/code> 的表达式，但你可以更进一步，使用 C 的可变参数宏把函数调用直接展开，并限定第一个参数是函数名，后面是参数，做成 &lt;code>TRY(some_function, arg1, arg2, &amp;quot;some_function failed&amp;quot;);&lt;/code> 这样的效果。顺带提一句，要求每个操作可能出错的函数都返回错误码是一个非常好的实践，比起 &lt;code>fopen()&lt;/code> 这样返回指针判断 &lt;code>NULL&lt;/code> 是否出错，然后从全局变量 &lt;code>errno&lt;/code> 拿错误码要直观很多，而且也免除了全局错误码变量的需求，保证了线程安全、提升了性能。&lt;/p>
&lt;p>如果你用 C++，可以做一个泛型 union，把泛型的函数返回值和错误码都封装起来一起作为函数返回值，到了这步，恭喜你重新发明了 Rust 的 &lt;code>Result&lt;/code>。&lt;/p>
&lt;p>这个语句表达式语法扩展除了 MSVC，主流的 GCC 和 LLVM Clang 都支持，这也是 VC 编译不了 Linux 内核的原因之一。如果你想看个 C++ 的例子，可以参考&lt;a href="https://github.com/SerenityOS/serenity/blob/master/AK/Try.h">SerenityOS 里的实现&lt;/a>。&lt;/p>
&lt;p>Have fun!&lt;/p>
- https://oldrev.github.io/2024/09/gcc-stateexpr/ - 李维（Li Wei）</description></item><item><title>Hello World</title><link>https://oldrev.github.io/2024/09/hello-world/</link><pubDate>Sat, 14 Sep 2024 00:44:25 +0800</pubDate><guid>https://oldrev.github.io/2024/09/hello-world/</guid><description>命叔瞎扯 https://oldrev.github.io/2024/09/hello-world/ -&lt;p>整个测试下&lt;/p>
- https://oldrev.github.io/2024/09/hello-world/ - 李维（Li Wei）</description></item></channel></rss>