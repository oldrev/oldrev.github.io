<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>命叔瞎扯</title><link>https://oldrev.github.io/</link><description>Recent content on 命叔瞎扯</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>李维（Li Wei）</copyright><lastBuildDate>Thu, 19 Sep 2024 12:00:00 +0800</lastBuildDate><atom:link href="https://oldrev.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust 交叉编译后用 QEMU 执行单元测试</title><link>https://oldrev.github.io/2024/09/rust-cross-qemu-test/</link><pubDate>Thu, 19 Sep 2024 12:00:00 +0800</pubDate><guid>https://oldrev.github.io/2024/09/rust-cross-qemu-test/</guid><description>命叔瞎扯 https://oldrev.github.io/2024/09/rust-cross-qemu-test/ -&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>本文介绍一种在 Linux 下通过 &lt;code>qemu-user-static&lt;/code> 工具对交叉编译的 Rust 程序执行单元测试的方法。&lt;/p>
&lt;h2 id="为何有此需求">为何有此需求？&lt;/h2>
&lt;p>最近用 Rust 做嵌入式 Linux 开发的时候，交叉编译完程序以后，为了保证质量，还需要对目标平台执行单元测试。问题来了，“qemu-user-static”只能转译执行单个可执行文件，而一般 Rust 程序的单元测试是通过 &lt;code>cargo test&lt;/code> 来执行的。解决这个问题的思路我们需要把单元测试编译成一个或者多个可执行文件让 QEMU 来执行，通过观察普通 &lt;code>cargo test&lt;/code> 的执行过程，我发现它本身就是把单元测试编译成一个可执行程序来执行的，只是该可执行文件的名称会在后面加上源码的哈希值，所以在持续集成等环境下，我们需要确定输出的可执行文件名。&lt;/p>
&lt;h2 id="调研-cargo-test">调研 Cargo Test&lt;/h2>
&lt;p>到了这一步，问题转换成了获取 Cargo 构建后测试可执行文件名，我看了下 &lt;code>cargo test --help&lt;/code> 发现并没有此项参数，但是另外两个参数引起了我的注意：&lt;/p>
&lt;p>&lt;code>--no-run&lt;/code>：此参数仅编译生成可执行的测试程序，而不实际执行单元测试。这对于交叉编译后的结果尤为重要，因为 Cargo 无法直接在本地执行目标平台的测试。&lt;/p>
&lt;p>&lt;code>--message-format=json&lt;/code> 表示使用 JSON 格式来输出构建信息到标准输出，带上这个参数执行 &lt;code>cargo test --message-format=json&lt;/code>，可以观察到最后输出了类似如下的 JSON 内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-javascript" data-lang="javascript">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;reason&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;compiler-artifact&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;target&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> { &lt;span style="color:#75715e">/* ... */&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;profile&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;test&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span> &lt;span style="color:#75715e">// 这里为 true 表示编译的 profile 就是测试
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">/*... */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;features&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [ &lt;span style="color:#75715e">/*...*/&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;filenames&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> [ &lt;span style="color:#75715e">/*...*/&lt;/span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 这里就是输出的测试可执行文件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;executable&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/YOUR_PROJ/target/YOUR_TARGET/debug/deps/your_executable-9a3afc990e4f7858&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* ... */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段 JSON 其实就包含所有我们需要的信息：这个输出结果是否是测试构建的结果，和测试程序路径。&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>问题明确后，解决方法变得简单明了。我们可以使用 jq 等命令行工具从 cargo test 的 JSON 输出中提取可执行文件路径，并交由 QEMU 执行。当然，你也可以编写一个 Python 脚本，以获得更大的灵活性。&lt;/p>
&lt;h2 id="一个例子">一个例子&lt;/h2>
&lt;p>假设你用的是 Ubuntu，先装上需要的工具：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install qemu qemu-user-static jq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入你的 Rust 项目，编写个简单 Bash 脚本交叉编译测试，这里假设目标平台为 32 位硬件浮点 ARM：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> exe in &lt;span style="color:#66d9ef">$(&lt;/span>cargo test --no-run --target armv7-unknown-linux-gnueabihf --message-format&lt;span style="color:#f92672">=&lt;/span>json | tee /dev/stderr | jq -r &lt;span style="color:#e6db74">&amp;#39;select(.profile.test == true) | .executable&amp;#39;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>; &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> echo &lt;span style="color:#e6db74">&amp;#34;Running tests in &lt;/span>$exe&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> qemu-arm -L /usr/arm-linux-gnueabihf $exe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个脚本很简单，把 &lt;code>cargo test&lt;/code> 的结果通过管道传给 &lt;code>tee&lt;/code>，&lt;code>tee&lt;/code> 这里是可选的，作用是把处理通过管道继续把 JSON 传给后面的 &lt;code>jq&lt;/code> 以外，还在命令行显示出来，便于我们调试编译错误。&lt;/p>
&lt;p>管道最后通过 &lt;code>jq&lt;/code> 提取可执行文件存入 &lt;code>$exe&lt;/code> 然后交给 QEMU 执行。这里之所以要用循环，是因为如果有多个 crates 在你的项目里 cargo 就会为每个 crate 产生一个测试程序。&lt;/p>
&lt;p>对于 ARM64 等其他架构，只需将 Cargo 的 &amp;ndash;target 参数改为相应的 Rust 构建目标，并将 qemu-arm 改为 qemu-aarch64，同时调整 /usr/arm-linux-gnueabihf 路径即可。完整的示例可参考我的开源项目 EdgeLink 的持续集成文件：&lt;a href="https://github.com/oldrev/edgelink/blob/master/.github/workflows/CICD.yml">https://github.com/oldrev/edgelink/blob/master/.github/workflows/CICD.yml&lt;/a>&lt;/p>
&lt;p>Have fun!&lt;/p>
- https://oldrev.github.io/2024/09/rust-cross-qemu-test/ - 李维（Li Wei）</description></item><item><title>使用 GCC 语句表达式模仿异常，简化错误处理</title><link>https://oldrev.github.io/2024/09/gcc-stateexpr/</link><pubDate>Sat, 14 Sep 2024 04:42:39 +0800</pubDate><guid>https://oldrev.github.io/2024/09/gcc-stateexpr/</guid><description>命叔瞎扯 https://oldrev.github.io/2024/09/gcc-stateexpr/ -&lt;p>嵌入式开发里，90% 情况下用的是 GCC，这里介绍一个 GCC 的 C 语言语法扩展，叫“语句表达式”（Statement Expression）。语句表达式，允许在表达式中包含多个语句，并返回最后一个表达式语句的值，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>, b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> ({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Calculating the sum of %d and %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, a, b);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;The result is %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个例子中，&lt;code>({ ... })&lt;/code> 是一个语句表达式。它首先会打印一条调试信息，然后计算 &lt;code>a + b&lt;/code> 并将结果返回给 &lt;code>result&lt;/code>。&lt;/p>
&lt;p>有了这个工具，可以很容易实现一个 &lt;code>TRY&lt;/code> 宏：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define TRY(expr, msg) ({ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> int result = (expr); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> if (result != 0) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> fprintf(stderr, &amp;#34;Error: %s\n&amp;#34;, msg); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> return result; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">})
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个宏里，我们判断 &lt;code>expr&lt;/code> 是否等于 &lt;code>0&lt;/code>，如果成功则继续执行，否则打印 &lt;code>msg&lt;/code> 并提前返回，以下是完整可以跑的示例代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define TRY(expr, msg) ({ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> int result = (expr); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> if (result != 0) { \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> fprintf(stderr, &amp;#34;Error: %s\n&amp;#34;, msg); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> return result; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> } \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">})
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">some_function&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 假设这是一个可能失败的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 成功返回 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// return -1; // 失败返回非零值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">TRY&lt;/span>(&lt;span style="color:#a6e22e">some_function&lt;/span>(), &lt;span style="color:#e6db74">&amp;#34;some_function failed&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Function succeeded, continuing...&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>用这个宏的时候有个要求，&lt;code>expr&lt;/code> 里的函数或者表达式必须以 &lt;code>int&lt;/code> 作为返回值。如果你不需要打印错误信息，可以直接去掉 &lt;code>msg&lt;/code> 参数，返回错误码就好。&lt;/p>
&lt;p>基本上 Rust 的 &lt;code>Ok/Err&lt;/code> 也是一样的原理，这个宏你还可以扩展，比如现在我们的宏里可以使用任何结果为 &lt;code>int&lt;/code> 的表达式，但你可以更进一步，使用 C 的可变参数宏把函数调用直接展开，并限定第一个参数是函数名，后面是参数，做成 &lt;code>TRY(some_function, arg1, arg2, &amp;quot;some_function failed&amp;quot;);&lt;/code> 这样的效果。顺带提一句，要求每个操作可能出错的函数都返回错误码是一个非常好的实践，比起 &lt;code>fopen()&lt;/code> 这样返回指针判断 &lt;code>NULL&lt;/code> 是否出错，然后从全局变量 &lt;code>errno&lt;/code> 拿错误码要直观很多，而且也免除了全局错误码变量的需求，保证了线程安全、提升了性能。&lt;/p>
&lt;p>如果你用 C++，可以做一个泛型 union，把泛型的函数返回值和错误码都封装起来一起作为函数返回值，到了这步，恭喜你重新发明了 Rust 的 &lt;code>Result&lt;/code>。&lt;/p>
&lt;p>这个语句表达式语法扩展除了 MSVC，主流的 GCC 和 LLVM Clang 都支持，这也是 VC 编译不了 Linux 内核的原因之一。如果你想看个 C++ 的例子，可以参考&lt;a href="https://github.com/SerenityOS/serenity/blob/master/AK/Try.h">SerenityOS 里的实现&lt;/a>。&lt;/p>
&lt;p>Have fun!&lt;/p>
- https://oldrev.github.io/2024/09/gcc-stateexpr/ - 李维（Li Wei）</description></item><item><title>Hello World</title><link>https://oldrev.github.io/2024/09/hello-world/</link><pubDate>Sat, 14 Sep 2024 00:44:25 +0800</pubDate><guid>https://oldrev.github.io/2024/09/hello-world/</guid><description>命叔瞎扯 https://oldrev.github.io/2024/09/hello-world/ -&lt;p>整个测试下&lt;/p>
- https://oldrev.github.io/2024/09/hello-world/ - 李维（Li Wei）</description></item></channel></rss>